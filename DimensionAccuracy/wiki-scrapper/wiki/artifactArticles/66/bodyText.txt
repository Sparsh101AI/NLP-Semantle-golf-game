Julia is a high-level, high-performance, dynamic programming language. While it is a general-purpose language and can be used to write any application, many of its features are well suited for numerical analysis and computational science.
Distinctive aspects of Julia's design include a type system with parametric polymorphism in a dynamic programming language; with multiple dispatch as its core programming paradigm. Julia supports concurrent, (composable) parallel and distributed computing (with or without using MPI or the built-in corresponding to "OpenMP-style" threads), and direct calling of C and Fortran libraries without glue code. Julia uses a just-in-time (JIT) compiler that is referred to as "just-ahead-of-time" (JAOT) in the Julia community, as Julia compiles all code (by default) to machine code before running it.
Julia is garbage-collected, uses eager evaluation, and includes efficient libraries for floating-point calculations, linear algebra, random number generation, and regular expression matching. Many libraries are available, including some (e.g., for fast Fourier transforms) that were previously bundled with Julia and are now separate.
Several development tools support coding in Julia, such as integrated development environments (e.g. for Microsoft's Visual Studio Code, an extension is available providing debugging and linting support); with integrated tools, e.g. a profiler (and flame graph support available for the built-in one), debugger, and the Rebugger.jl package "supports repeated-execution debugging" and more.
Work on Julia was started in 2009, by Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and Alan Edelman, who set out to create a free language that was both high-level and fast. On 14 February 2012, the team launched a website with a blog post explaining the language's mission. In an interview with InfoWorld in April 2012, Karpinski said of the name "Julia": "There's no good reason, really. It just seemed like a pretty name." Bezanson said he chose the name on the recommendation of a friend, then years later wrote:
In the 10 years since the 2012 launch of pre-1.0 Julia, the community has grown, and as of as of June 2022 Julia has been downloaded by users at "more than 10,000 companies" with over 35 million downloads and over "1,500 universities worldwide are using and teaching Julia, including MIT, Stanford and UC Berkeley. Companies and organizations using Julia include Amazon, Apple, AstraZeneca, Capital One, FAA, Google, IBM, Intel, JP Morgan, Microsoft, Moderna, NASA, Pfizer, Uber, the US Federal Reserve and every US national energy laboratory." The Julia package ecosystem has over 11.8 million lines of code (including docs and tests). The JuliaCon academic conference for Julia users and developers has been held annually since 2014 with JuliaCon2020 welcoming over 28,900 unique viewers, and then JuliaCon2021 breaking all previous records (with more than 300 JuliaCon2021 presentations available for free on YouTube, up from 162 the year before), and 43,000 unique viewers during the conference.
Both Julia 0.7 and version 1.0 were released on 8 August 2018. Work on Julia 0.7 was a "huge undertaking" (e.g., because of an "entirely new optimizer"), and some changes were made to semantics, e.g. the iteration interface was simplified; and the syntax changed a little (with the syntax now stable, and same for 1.x and 0.7).
Julia 1.1 was released in January 2019 with a new "exception stack" feature. 
Julia 1.2 was released in August 2019 with some built-in support for web browsers.
Julia 1.3 added composable multi-threaded parallelism and a binary artifacts system for Julia packages.
Julia 1.4 added syntax for generic array indexing to handle e.g. 0-based arrays. The memory model was also changed.
Julia 1.5 released in August 2020 added record and replay debugging support, for Mozilla's rr tool.  The release changed the behavior in the REPL (soft scope) to the one used in Jupyter, but fully compatible with non-REPL code. Most of the thread API was marked as stable, and with this release "arbitrary immutable objects—regardless of whether they have fields that reference mutable objects or not—can now be stack allocated", reducing heap allocations, e.g. views are no longer allocating.  Julia 1.5 targeted so-called "time-to-first-plot" performance, in general, the speed of compilation itself (as opposed to performance of the generated code), and adds tools for developers to improve package loading.
Julia 1.6 was the largest release since 1.0, faster on many fronts, e.g. introduced parallel precompilation and faster loading of packages, in some cases "50x speedup in load times for large trees of binary artifacts".
As of version 1.7 Julia development is back to time-based releases.
Julia 1.7.0 was released in November 2021, with many changes, e.g. a new faster random-number generator.
Julia 1.7.3 was released on 25 May 2022, fixing some issues, including at least one security update.
Julia 1.8  is out as a release candidate version (with improvements regarding distributing Julia programs without source code,  and compiler speedup, in some cases by 25%  and more controllable inlining, e.g. at the function call site) and Julia 1.9 is the next milestone, it and the milestone for 1.10 and 2.0 currently have no set due dates.
Julia has attracted some high-profile users, from investment manager BlackRock, which uses it for time-series analytics, to the British insurer Aviva, which uses it for risk calculations. Since 2015, the Federal Reserve Bank of New York has used Julia to make models of the United States economy (including estimating COVID-19 shocks in 2021), noting that the language made model estimation "about 10 times faster" than its previous MATLAB implementation. At the 2017 JuliaCon conference, Jeffrey Regier, Keno Fischer and others announced that the Celeste project used Julia to achieve "peak performance of 1.54 petaFLOPS using 1.3 million threads" on 9300  Knights Landing (KNL) nodes of the Cori II (Cray XC40) supercomputer (then 6th fastest computer in the world). Julia thus joins C, C++, and Fortran as high-level languages in which petaFLOPS computations have been achieved.
Three of the Julia co-creators are the recipients of the 2019 James H. Wilkinson Prize for Numerical Software (awarded every four years) "for the creation of Julia, an innovative environment for the creation of high-performance tools that enable the analysis and solution of computational science problems." Also, Alan Edelman, professor of applied mathematics at MIT, has been selected to receive the 2019 IEEE Computer Society Sidney Fernbach Award "for outstanding breakthroughs in high-performance computing, linear algebra, and computational science and for contributions to the Julia programming language."
In 2019, Julia Computing announced "the availability of the Julia programming language as a pre-packaged container on the NVIDIA GPU Cloud (NGC) container registry" and a blog post at Nvidia's site states "Easily Deploy Julia on x86 and Arm [..] Julia offers a package for a comprehensive HPC ecosystem covering machine learning, data science, various scientific domains and visualization."
Additionally, "Julia was selected by the Climate Modeling Alliance as the sole implementation language for their next generation global climate model. This multi-million dollar project aims to build an earth-scale climate model providing insight into the effects and challenges of climate change."
Julia is used by NASA, e.g. for modeling spacecraft separation dynamics (15,000 times faster than before with Simulink/MATLAB) and the Brazilian INPE for space mission planning and satellite simulation. Another effort is working on an embedded project to control a satellite in space using Julia for attitude control.
Since 2014, the Julia Community has hosted an annual Julia Conference focused on developers and users. The first JuliaCon took place in Chicago and kickstarted the annual occurrence of the conference. Since 2014, the conference has taken place across a number of locations including MIT and the University of Maryland, Baltimore. The event audience has grown from a few dozen people to over 28,900 unique attendees during JuliaCon 2020, which took place virtually. JuliaCon 2021 also took place virtually with keynote addresses from professors William Kahan (the primary architect of the IEEE 754 floating-point standard, which his keynote is about, that virtually all CPUs use and languages, including Julia), and Jan Vitek, Xiaoye Sherry Li, and Soumith Chintala (co-creator of PyTorch). JuliaCon grew to 43,000 unique attendees and more than 300 presentations (still freely accessible, plus for older years). JuliaCon 2022 will also be virtual held between July 27 and July 29, 2022, for the first time in several languages, not just in English.
The Julia language became a NumFOCUS fiscally sponsored project in 2014 in an effort to ensure the project's long-term sustainability. Dr. Jeremy Kepner at MIT Lincoln Laboratory was the founding sponsor of the Julia project in its early days. In addition, funds from the Gordon and Betty Moore Foundation, the Alfred P. Sloan Foundation, Intel, and agencies such as NSF, DARPA, NIH, NASA, and FAA have been essential to the development of Julia. Mozilla, the maker of Firefox web browser, with its research grants for H1 2019, sponsored "a member of the official Julia team" for the project "Bringing Julia to the Browser", meaning to Firefox  and other web browsers. The Julia language is also supported by individual donors on GitHub.
Julia Computing, Inc. was founded in 2015 by Viral B. Shah, Deepak Vinchhi, Alan Edelman, Jeff Bezanson, Stefan Karpinski and Keno Fischer.
In June 2017, Julia Computing raised US$4.6 million in seed funding from General Catalyst and Founder Collective, the same month was "granted $910,000 by the Alfred P. Sloan Foundation to support open-source Julia development, including $160,000 to promote diversity in the Julia community", and in December 2019 the company got $1.1 million funding from the US government to "develop a neural component machine learning tool to reduce the total energy consumption of heating, ventilation, and air conditioning (HVAC) systems in buildings". In July 2021, Julia Computing announced they raised a $24 million Series A led by Dorilton Ventures, which also owns Formula 1 team Williams Racing, that partnered with Julia Computing. Williams' Commercial Director said: "Investing in companies building best-in-class cloud technology is a strategic focus for Dorilton and Julia's versatile platform, with revolutionary capabilities in simulation and modelling, is hugely relevant to our business. We look forward to embedding Julia Computing in the world's most technologically advanced sport".
Julia is a general-purpose programming language, while also originally designed for numerical/technical computing.
It is also useful for low-level systems programming, as a specification language, High-level Synthesis (HLS) tool (for hardware, e.g. FPGAs), and for web programming at both server and client side.
The main features of the language are:
Multiple dispatch: providing ability to define function behavior across many combinations of argument types
Dynamic type system: types for documentation, optimization, and dispatch
Performance approaching that of statically-typed languages like C
A built-in package manager
Lisp-like macros and other metaprogramming facilities
Call C functions directly: no wrappers or special APIs
Ability to interface with other languages, e.g. PythonCall.jl allows calling to or from Python (also possible to call with PyCall.jl), R with RCall.jl, and Java/Scala with JavaCall.jl
Powerful shell-like abilities to manage other processes
Designed for parallel and distributed computing
Coroutines: lightweight green threading
User-defined types are as fast and compact as built-ins
Automatic generation of efficient, specialized code for different argument types
Elegant and extensible conversions and promotions for numeric and other types
Efficient support for Unicode, including but not limited to UTF-8Multiple dispatch (also termed multimethods in Lisp) is a generalization of single dispatch –  the polymorphic mechanism used in common object-oriented programming (OOP) languages, such as Python, C++, Java, JavaScript, and Smalltalk –  that uses inheritance. In Julia, all concrete types are subtypes of abstract types, directly or indirectly subtypes of the Any type, which is the top of the type hierarchy. Concrete types can not themselves be subtyped the way they can in other languages; composition is used instead (see also inheritance vs subtyping).
By default, the Julia runtime must be pre-installed as user-provided source code is run. Alternatively, a standalone executable that needs no Julia source code can be built with PackageCompiler.jl.
Julia's syntactic macros (used for metaprogramming), like Lisp macros, are more powerful than text-substitution macros used in the preprocessor of some other languages such as C, because they work at the level of abstract syntax trees (ASTs). Julia's macro system is hygienic, but also supports deliberate capture when desired (like for anaphoric macros) using the esc construct.
Julia draws significant inspiration from various dialects of Lisp, including Scheme and Common Lisp, and it shares many features with Dylan, also a multiple-dispatch-oriented dynamic language (which features an ALGOL-like free-form infix syntax rather than a Lisp-like prefix syntax, while in Julia "everything" is an expression), and with Fortress, another numerical programming language (which features multiple dispatch and a sophisticated parametric type system). While Common Lisp Object System (CLOS) adds multiple dispatch to Common Lisp, not all functions are generic functions.
In Julia, Dylan, and Fortress, extensibility is the default, and the system's built-in functions are all generic and extensible. In Dylan, multiple dispatch is as fundamental as it is in Julia: all user-defined functions and even basic built-in operations like + are generic. Dylan's type system, however, does not fully support parametric types, which are more typical of the ML lineage of languages. By default, CLOS does not allow for dispatch on Common Lisp's parametric types; such extended dispatch semantics can only be added as an extension through the CLOS Metaobject Protocol. By convergent design, Fortress also features multiple dispatch on parametric types; unlike Julia, however, Fortress is statically rather than dynamically typed, with separate compiling and executing phases. The language features are summarized in the following table:
An example of the extensibility of Julia, the Unitful.jl package adds support for physical units of measurement to the language.
The Julia official distribution includes an interactive command-line read–eval–print loop (REPL), with a searchable history, tab completion, and dedicated help and shell modes, which can be used to experiment and test code quickly. The following fragment represents a sample session example where strings are concatenated automatically by println:
The REPL gives user access to the system shell and to help mode, by pressing ; or ? after the prompt (preceding each command), respectively. It also keeps the history of commands, including between sessions. Code can be tested inside the Julia's interactive section or saved into a file with a .jl extension and run from the command line by typing:
Julia is supported by Jupyter, an online interactive "notebooks" environment, and Pluto.jl, a "reactive notebook" (where notebooks are saved as pure Julia files), a possible replacement for the former kind.
Julia is in practice interoperable with many languages (e.g. majority of top 10–20 languages in popular use). Julia's ccall keyword is used to call C-exported or Fortran shared library functions individually, and packages are available to allow calling other languages e.g. Python, R, MATLAB, C# (and other .NET languages with DotNET.jl), JavaScript, Java (and other JVM languages, such as Scala with JavaCall.jl). And packages for other languages allow to call to Julia, e.g. from Python, R, Rust or Ruby, such as with pyjulia and JuliaCall for R. Julia has also been used for hardware, i.e. to compile to VHDL, as a High-level Synthesis (HLS) tool (for e.g. FPGAs).
Julia has support for Unicode 13.0 (or the latest Unicode 14.0 with the release candidate of Julia 1.8) with UTF-8 used for strings (by default) and for Julia source code (only allowing legal UTF-8 in the latest version), meaning also allowing as an option common math symbols for many operators, such as ∈ for the in operator.
Julia has packages supporting markup languages such as HTML (and also for HTTP), XML, JSON and BSON, and for databases and web use in general.
Julia has a built-in package manager and includes a default registry system. Packages are most often distributed as source code hosted on GitHub, though alternatives can also be used just as well. Packages can also be installed as binaries, using artifacts. Julia's package manager is used to query and compile packages, as well as managing environments. Federated package registries are supported, allowing registries other than the official to be added locally.
Julia's core is implemented in Julia and C, together with C++ for the LLVM dependency. The parsing and code-lowering are implemented in FemtoLisp, a Scheme dialect. The LLVM compiler infrastructure project is used as the back end for generation of 64-bit or 32-bit optimized machine code depending on the platform Julia runs on. With some exceptions (e.g., PCRE), the standard library is implemented in Julia. The most notable aspect of Julia's implementation is its speed, which is often within a factor of two relative to fully optimized C code (and thus often an order of magnitude faster than Python or R). Development of Julia began in 2009 and an open-source version was publicized in February 2012.
While Julia has tier 1 macOS support, meaning for Intel-based Macs, and also for the new Apple M1-based Macs when run in Rosetta 2 emulation. Older Julia version 1.7.2, and the LTS version, and 1.8-DEV have tier 3 (experimental) support for the ARM-based M1 Mac with native full-speed (Windows on ARM has no official support yet). The work on that support (i.e. without emulation) is mostly done, and many programs may work if such a build of Julia is used. Julia is claimed to work "ok" on M1 Macs (at reduced performance) through the (automatic) use of Rosetta 2 (that needs to emulate Julia).
Since Julia uses JIT, Julia generates native machine code directly, before a function is first run (i.e. a different approach than compiling to bytecode, that you distribute by default, to be run on a virtual machine (VM), as with e.g. Java/JVM; then translated from the bytecode while running, as done by Dalvik on older versions of Android).
Julia has four support tiers. All IA-32 processors completely implementing the i686 subarchitecture are supported and 64-bit x86-64 (aka amd64), i.e. all less than about a decade old are supported. ARMv8 (AArch64) processors are supported on second tier, and ARMv7 and ARMv6 (AArch32) are supported with some caveats (lower tier) for Julia 1.0.x and also had official executables for later versions, while 32-bit ARM support was later downgraded to tier 3 (however, unofficial binaries are available for Julia 1.5.1). CUDA (i.e. Nvidia GPUs; implementing PTX) has tier 1 support, with the help of an external package. There are also additionally packages supporting other accelerators, such as Google's TPUs, and some Intel (integrated) GPUs, through oneAPI.jl, and AMD's GPUs have support with e.g. OpenCL; and experimental support for the AMD ROCm stack. Julia's downloads page provides executables (and source) for all the officially supported platforms.
On some platforms, Julia may need to be compiled from source code (e.g., the original Raspberry Pi), with specific build options, which has been done and unofficial pre-built binaries (and build instructions) are available. Julia has been built 
on several ARM platforms. PowerPC (64-bit) has tier 3 support, meaning it "may or may not build".
Julia is now supported in Raspbian while support is better for newer Pis, e.g., those with ARMv7 or newer; the Julia support is promoted by the Raspberry Pi Foundation.
There is also support for web browsers/JavaScript through JSExpr.jl; and the alternative language of web browsers, WebAssembly, has minimal support for several upcoming external Julia projects.
Julia can compile to ARM; thus, in theory, Android apps can be made with the NDK, but for now Julia has been made to run under Android only indirectly, i.e. with a Ubuntu chroot on Android.
While Julia requires an operating system by default, and has no official support to run without or on embedded system platforms like Arduino, Julia code has still been run, with some limitations, on a baremetal 16 MHz 8-bit AVR-microcontroller Arduino with 2 KB RAM (plus 32 KB of flash memory).
Comparison of numerical-analysis software
Comparison of statistical packages
Differentiable programmingNagar, Sandeep (2017). Beginning Julia Programming: For Engineers and Scientists. Springer. ISBN 9781484231715.
Bezanson, J; Edelman, A; Karpinski, S; Shah, V. B (2017). "Julia: A fresh approach to numerical computing". SIAM Review. 59 (1): 65–98. arXiv:1411.1607. CiteSeerX 10.1.1.760.8894. doi:10.1137/141000671. S2CID 13026838.
Joshi, Anshul (2016). Julia for Data Science － Explore the world of data science from scratch with Julia by your side. Packt. ISBN 9781783553860.Official website
julia on GitHub